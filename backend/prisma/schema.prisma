// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id       Int      @id @default(autoincrement()) @map("user_id")
  full_name     String   @map("full_name")
  email         String   @unique
  password_hash String   @map("password_hash")
  university    String?
  department    String?
  created_at    DateTime @default(now()) @map("created_at")

  profile          UserProfile?       @relation("UserProfileToUser")
  subjects         UserSubject[]      @relation("UserSubjectToUser")
  created_rooms    Room[]             @relation("RoomCreator")
  room_participations RoomParticipant[] @relation("RoomParticipantToUser")
  sent_messages    Message[]          @relation("MessageSender")
  reports_made     Report[]           @relation("ReportReporter")
  notifications    Notification[]     @relation("NotificationReceiver")

  @@map("users")
}

model UserProfile {
  profile_id      Int       @id @default(autoincrement()) @map("profile_id")
  user_id         Int       @unique @map("user_id") // Make user_id unique here for one-to-one
  bio             String?
  profile_picture String?   @map("profile_picture")
  is_online       Boolean   @default(false) @map("is_online")
  last_active     DateTime? @map("last_active")

  user User @relation("UserProfileToUser", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("user_profiles")
}

model Subject {
  subject_id  Int      @id @default(autoincrement()) @map("subject_id")
  name        String
  description String?

  user_subjects UserSubject[] @relation("UserSubjectToSubject")
  rooms         Room[]        @relation("RoomSubject")

  @@map("subjects")
}

model UserSubject {
  id                    Int     @id @default(autoincrement())
  user_id               Int     @map("user_id")
  subject_id            Int     @map("subject_id")
  skill_level           String? @map("skill_level") // Consider Enum later if needed
  interested_in_helping Boolean @default(true) @map("interested_in_helping")

  user    User    @relation("UserSubjectToUser", fields: [user_id], references: [user_id], onDelete: Cascade)
  subject Subject @relation("UserSubjectToSubject", fields: [subject_id], references: [subject_id], onDelete: Cascade)

  @@map("user_subjects")
}

model Room {
  room_id     Int      @id @default(autoincrement()) @map("room_id")
  room_name   String   @map("room_name")
  subject_id  Int?     @map("subject_id")
  is_public   Boolean  @default(true) @map("is_public")
  created_by  Int?     @map("created_by")
  created_at  DateTime @default(now()) @map("created_at")

  subject          Subject?          @relation("RoomSubject", fields: [subject_id], references: [subject_id])
  creator          User?             @relation("RoomCreator", fields: [created_by], references: [user_id])
  participants     RoomParticipant[] @relation("RoomParticipantToRoom")
  messages         Message[]         @relation("MessageToRoom")

  @@map("rooms")
}

model RoomParticipant {
  id        Int      @id @default(autoincrement())
  room_id   Int      @map("room_id")
  user_id   Int      @map("user_id")
  joined_at DateTime @default(now()) @map("joined_at")

  room Room @relation("RoomParticipantToRoom", fields: [room_id], references: [room_id], onDelete: Cascade)
  user User @relation("RoomParticipantToUser", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("room_participants")
}

model Message {
  message_id   Int      @id @default(autoincrement()) @map("message_id")
  room_id      Int      @map("room_id")
  sender_id    Int?     @map("sender_id") // Nullable if sender can be deleted? Or handle differently. Assuming sender is required. Made non-nullable.
  message_type String   @default("text") @map("message_type") // 'text', 'image', 'pdf'
  message_text String?  @map("message_text")
  file_url     String?  @map("file_url")
  sent_at      DateTime @default(now()) @map("sent_at")
  is_edited    Boolean  @default(false) @map("is_edited")

  room    Room     @relation("MessageToRoom", fields: [room_id], references: [room_id], onDelete: Cascade)
  sender  User?    @relation("MessageSender", fields: [sender_id], references: [user_id]) // Made sender optional relation in case user deleted
  reports Report[] @relation("ReportToMessage")

  @@map("messages")
}

model Report {
  report_id   Int      @id @default(autoincrement()) @map("report_id")
  message_id  Int      @map("message_id")
  reported_by Int?     @map("reported_by") // Made optional in case reporter deleted
  reason      String?
  reported_at DateTime @default(now()) @map("reported_at")

  message     Message @relation("ReportToMessage", fields: [message_id], references: [message_id], onDelete: Cascade)
  reporter    User?   @relation("ReportReporter", fields: [reported_by], references: [user_id])

  @@map("reports")
}

model Notification {
  notification_id Int      @id @default(autoincrement()) @map("notification_id")
  user_id         Int?     @map("user_id") // Made optional in case user deleted
  content         String
  is_read         Boolean  @default(false) @map("is_read")
  created_at      DateTime @default(now()) @map("created_at")

  user User? @relation("NotificationReceiver", fields: [user_id], references: [user_id])

  @@map("notifications")
}
